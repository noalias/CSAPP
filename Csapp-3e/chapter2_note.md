## 位级表示及运算
### 位级表示
1. 十六进制与二进制
    * 十六进制与二进制互相转化，每位十六进制数可转化为4位二进制数，反之亦可。
    * w位的二进制数10.....0可转化为2的（w-1）次幂的十进制数。
2. 数据的机器级表示法
如果一个数据的长度大于一个字节，那么不同的机器，基于字节对该数据的排列，会有不同的方式。
    + **大端表示法**：参照二进制数的书写习惯（高位在左边，低位在右边），自高位开始依次排列**数据字节**；
    + **小端表示法**：参照二进制数的书写习惯，自低位开始依次排列数据字节。
    + 使用以下函数可以查看当前机器的数据表示方法：  
<pre><code>#include <stdio.h>  
typedef unsigned char *byte_pointer;   // 定义一个指向一个字节的指针  
void show_bytes(byte_pointer start, size_t len)
{  // 定义一个遍历每一字节数据的函数
	   size_t i;
	   for (i = 0; i < len; i++)
            printf(" %.2x", start[i]);
        printf("\n");
}  
void show_int(int x)
{  // 展示int型数据的排列方式
        show_bytes(byte_pointer) &x, sizeof(int));
}  
void show_float(float x)
{ // 展示float型数据的排列方式
        show_bytes(byte_pointer) &x, sizeof(float));
}  
void show_int(void *x)
{ // 展示指针型数据的排列方式
        show_bytes(byte_pointer) &x, sizeof(void *));
}
</pre></code>
3. 位向量
位向量是固定长度为w，由0、1组成的串。
位向量的特性：
     * 位向量的表示是从高有效位到低有效位，用下标w-1,w-2,w-3......1,0依次标记；
     * 位向量的运算是对位向量的各个相对应的元素依次进行运算；
     - 用位向量可以表示位模式。
### 位级运算
4. 运算
     - 位级运算：按位进行布尔运算，包括&、|、～、^；
     > 掩码运算，掩码是一个*位模式*，表示从一个**字**中选出位的集合。0xff表示字的最低8位为1，表达式～0表示全1的掩码。
     - 逻辑运算：逻辑运算表达式，返回true和false；
     >运算符号：&&，操作数同为非零数，返回true；||，只要有一个操作数非零，则返回true；！，将非零转化为false（0），将零转化为true（1）。  
     >&&与||的一个特性，当第一个操作数就能判定运算的值，则第二个操作数将被忽略，比如，a && 5 / a，如果a为零，则表达式立即判定为fasle（0），而第二个表达式被忽略，即5不会被0整除。
     - 移位运算：对位模式整体向**左**或**右**移动一定位数。包括：左移<<，向左移动一定位数，并用相应个数的0填补；逻辑右移>>，向右移动一定位数，并用相应个数的0填补；算术右移>>，向右移动一定位数，并用相应个数的位模式最高有效位填补。
     >对于右移，一般计算机默认无符号数采用逻辑右移，补码采用算术右移。

## 整数表示及运算
### 整数的表示
1. 一个整数数据类型的位模式，可以用一个唯一的位向量表示。位向量$\vec x=[x_{w-1},x_{w-2},……,x_1,x_0]$，表示w位的位模式，位向量的各元素与位模式的各个二进制位一一对应。
>例如 [11001]表示二进制11001。
2. 位模式编码无符号数。  
用函数B2U<sub>w</sub>定义位模式对无符号数的编码，规则如下：
$$B2U(\vec x) \dot = \sum_{i=0}^{w-1}x_i2^i$$
    - 符号$\dot =$表示**定义为**;  
    - 例如: $B2U([11001])=1\times2^4+1\times2^3+0\times2^3+0\times2^1+1\times2^0=25$;  
    - 显然，$x_i=0$,函数取最小值0；$x_i=1$,函数取最大值。即，$$\begin{split}UMin_w & = 0\\UMax_w & =\sum_{i=0}^{w-1}2^i=2^w-1\end{split}$$  
    - 函数$B2U_w$是一个双射，意味着函数$B2U_w$将w位的位向量映射为$0\to2^{w-1}$之间的唯一值；反过来，对于函数$U2B_w$将$0\to2^{w-1}$之间的每一个整数映射为唯一的位模式。
3. 位模式编码补码。  
用函数$B2T_w$定义位模式对补码的编码，规则如下：
$$B2T(\vec x) \dot = -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$$
    - 补码的最高有效位称为**符号位**，$x_{w-1}$为1时，值为负数，为0时,值为非负数；也称为**负权**,**权重**为$-2^{w-1}$。
    - 显然，最高有效位$x_{w-1}=1$,其余有效位$x_i=0$时，函数取最小值；最高有效位$x_{w-1}=0$,其余有效位$x_i=1$时，函数取最大值。即，$$\begin{split}TMin_w &=-2^{w-1}\\TMax_w&=\sum_{i=0}^{w-2}2^i=2^{w-1}-1\end{split}$$
    - 函数$B2T_w$是一个双射，意味着函数$B2T_w$将w位的位向量映射为$-2^{w-1}\to2^{w-1}-1$之间的唯一值；反过来，对于函数$T2B_w$将$-2^{w-1}\to2^{w-1}-1$之间的每一个整数映射为唯一的位模式。  
    - 通过比较TWin与TMax,|TWin|比|TMax|大1,即补码是不对称的，原因在于w位能编码的值总数为$2^w-1$为奇数，具体而言，0占了一个非负数位，所以，正数总是比负数少一位。
### 无符号数与补码之间的转换
无符号数、补码都与位向量一一对应，那么可以通过将无符号数先转换为位向量，在通过位向量转换为补码，反之亦可；通过位向量的过渡，确定了无符号数与补码的转换方式。对以下所有运算，u表示无符号数，x表示补码，所有运算在w位级上进行。

1. 无符号数转换为补码
    - 用函数$U2T_w$定义w位无符号数转换为补码，规则如下：$$U2T_w(u)=B2T(U2B_w(u))$$
    >推导：$$\begin{split}U2T_w(u)&=B2T_w(\vec x)\\&=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\\&=-x_{w-1}2^{w-1}+u-x_{w-1}2^{w-1}\\&=-x_{w-1}2^w+u\end{split}$$  
    >上式中：$$\begin{split}\vec x&=U2B_w(u)\\B2U_w(\vec x)=u&=\sum_{i=0}^{w-1}x_i2^i\to\sum_{i=0}^{w-2}x_i2^i=u-x_{w-1}2^{w-1}\end{split}$$  
    >当最高有效位：$x_{w-1}=0$，$U2T_w=u$；$x_{w-1}=1$，$U2T_w=u-2^w$；    
    >无符号数u与最高有效位$x_{w-1}$的关系：当$u \gt TMax_w$，$x_{w-1}=1$；当$0 \le u \le TMax_w$，$x_{w-1}=0$；  
    - 综上，对于$0 \le u \le UMax_w$，无符号数转换为补码的表达式：$$U2T_w(u)=\begin{cases}u&0 \le u \le TMax_w\\u-2^w&u \gt TMax_w\end{cases}$$
2. 补码转换为无符号数
    - 用函数$T2U_w$定义w位的补码转换为无符号数，规则如下：$$T2U_w(x)=B2U(T2B_w(x))$$
    >推导：$$\begin{split}T2U_w(x)&=B2U_w(\vec x)\\&=\sum_{i=0}^{w-1}x_i2^i\\&=x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\\&=x_{w-1}2^{w-1}+x+x_{w-1}2^{w-1}\\&=x_{w-1}2^w+x\end{split}$$  
    >上式中：$$\begin{split}\vec x&=T2B_w(x)\\B2T_w(\vec x)=x&=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\to\sum_{i=0}^{w-2}x_i2^i=x+x_{w-1}2^{w-1}\end{split}$$  
    >当最高有效位：$x_{w-1}=0$，$T2U_w=x$；$x_{w-1}=1$，$T2U_w=2^w+x$；&emsp;
    >补码x与最高有效位$x_{w-1}$的关系：当$x \lt 0$，$x_{w-1}=1$；当$x \ge 0$，$x_{w-1}=0$；
    - 综上，对于$TMin_w \le x \le TMax_w$，补码转换为无符号数的表达式：$$T2U_w(x)=\begin{cases}2^w+x&x \lt 0\\x&x \ge 0\end{cases}$$
3. 总结
    - 对于w位位模式，最高有效位$x_{w-1}=0$时，u=x；$x_{w-1}=1$时，u-x=$2^w$；即，$u-x=x_{w-1}2^w$。
4. 应用
c语言中，补码与无符号数的转换一般有以下几种情况：
    - 类型强制转换；
    - 赋值时隐式转换；
    - printf函数中，格式串的**转换说明**指代了类型不符的参数；
    - 运算操作符的操作数类型不同，会隐式地将补码转换为无符号数，**这可能导致关系运算的结果与预期相悖**。
### 数字扩展与截断
1. 扩展运算
对数字按不同的规则进行位扩展，可以保持数字不变。
    - 无符号数**零扩展**，即扩展的高有效位补齐**零**。
    >推导：$$\begin{split}B2U([0_{w-1+k},0_{w-2+k},……0_w,x_{w-1},x_{w-2},……,x_1,x_0])&=\sum_{i=0}^{w-1+k}x^i2^i\\&=0_{w-1+k}+0_{w-2+k}+……+0_w+\sum_{i=0}^{w-1}x_i2^i\\&=B2U([x_{w-1},x_{w-2},……,x_1,x_0])\end{split}$$&emsp;
    >上式中：按规则，扩展了k位，扩展后的位模式所表示的数字不变。
    - 补码**符号扩展**，即扩展的高有效位补齐符号位**对应的数字**。
    >推导：
    >
    >1. 当补码最高有效位为0时，补码的扩展为**零扩展**;&emsp;
    >2. 当不吗的最高有效位为1时：$$\begin{split}B2T([1_{w-1+k},1_{w-2+k},……1_w,1_{w-1},x_{w-2},……,x_1,x_0])&=-2^{w-1+k}+\sum_{i=0}^{w-2+k}x^i2^i\\&=-2^{w-1+k}+2^{w-2+k}+\sum_{i=0}^{w-3+k}x_i2^i\\&=-2^{w-2+k}+\sum_{i=0}^{w-4+k}x_i2^i\\&=-2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\\&=B2T([x_{w-1},x_{w-2},……,x_1,x_0])\end{split}$$&emsp;
    >综上，补码按**符号扩展**,扩展后的位模式表示的树不变。
    - 对于C语言，低位类型进行扩展运算，同时进行符号转换，将遵循先**扩展**位，再进行无符号与补码的转换。
2. 截断运算
对数字的截断运算，主要运用于处理数字溢出。
    - 无符号数的截断  
如对$\vec x$截断k位，截断后的数字为$u_1$，那么$u_1=u mod 2^k$
    >推导：$$\begin{split}u_1&=umod2^k\\&=B2T([x_{w-1},x_{w-2},……,x_1,x_0])mod2^k\\&=[x_{w-1}2^{w-1}+x_{w-2}2^{w-2}+……+x_k2^k+\sum_{i=0}^{k-1}x_i2^i]mod2^k\\&=\sum_{i=0}^{k-1}x_i2^i\\&=B2T([x_{k-1},x_{k-2},……,x_1,x_0])\end{split}$$
    >上式中，运用了$i \ge k,2^imod2^k=0$的取模运算。
    - 补码的截断  
补码与无符号数具有相同的位模式，补码的截断运算，是先将补码转换为无符号数，取模后再转换为补码。即，截断k位后的补码：$$x_1=xmod2^k=U2T_w(T2U(x)mod2^k)$$
### 整数的运算
1. 无符号数的加法  
    - 对于$0 \le x \le 2^w$-1和$0 \le y \le 2^w$-1，有$0 \le x+y \le 2^{w+1}-2$表示x+y的位模式最大w+1位，而字长是有限的，则：$$x+_w^uy\dot =(x+y)mod2^w$$
>推导：  
>1. 当$0 \le x+y \le 2^w-1$时，表示位模式最多w位，即$$(x+y)mod2^w=x+y$$
>2. 当$2^w \le x+y \le 2^{w+1}-2$时，表示位模式最多w+1位，即$$(x+y)mod2^w=x+y-2^w$$
>综上，用$x+_w^uy$表示无符号数的加法，则：$$x+_w^uy=\begin{cases}x+y&0 \le x+y \le 2^w-1&正常\\x+y-2^w&2^w \le x+y \le 2^{w+1}-2&溢出\end{cases}$$
>**溢出**是指完整的整数结果不能放到数据类型的字长限制中去。
    - 检测无符号数加法中的溢出  
令$s\dot =x+_w^uy$，当$s \lt x$(或等价的$s \lt y$)时，发生溢出。
>推导：  
>$x+y \ge x$(这里是x+y，而不是$x +_w^uy$)，若未发生溢出，则$s=(x+y) \ge x$；  
>若发生溢出，则$s=x+_w^uy=x+y-2^w$，而$y \lt 2^w \to y-2^w \lt 0 \to x+y-2^w \lt x$，即$s \lt x$。
    - 无符号数求反
用无符号数的加法，表示阿贝尔群：$$-_w^ux+_w^ux=0$$，其中$-_w^ux$与x互为加法逆元。
>推导：  
>当x=0时，其加法逆元显然是0;  
>当$x \gt 0$时，$$\begin{split}-_w^ux+_w^ux&=(-_w^ux+x)mod2^w\\&=0\\&=2^wmod2^w\end{split}$$即$-_w^ux+x=2^w \to -_w^ux=2^w-x$。  
>综上，$$-_w^ux=\begin{cases}0&x=0\\2^w-x&x \gt 0\end{cases}$$  
>**应用**:  
>对于$-_4^u(0X6)=2^4-6=10$
2. 补码的加法
    - 对于$-2^{w-1} \le x,y \le 2^{w-1}-1$，有$-2^w \le x+y \le 2^w-2$，这表明x+y需要**w+1**位，由于字长的限制，x+y需截断为w位，同时补码加法与无符号数加法具有相同的位级表示，即：$$\begin{split}x+_w^ty\dot =&U2T_w(T2U_w(x)+_w^uT2U_w(y))\\=&U2T_w[(x+x_{w-1}2^w+y+y_{w-1}2^w)mod2^w]\\=&U2T_w[(x+y)mod2^w]\end{split}$$
    >推导：
    >令**w+1**位的$z\dot = x+y$,**w**位的$z_1\dot =zmod2^w$,$z_2\dot =U2T_w(z_1)$  
    >1. 当$-2^w \le z \lt-2^{w-1}$，即z的$z_w$位为1，$z_{w-1}$位为0，故$$\begin{split}z_1&=zmod2^w\\&=(z_w2^w+z_{w-1}2^{w-1}+\sum_{i=0}^{w-2}z_i2^i)mod2^w\\&=\sum_{i=0}^{w-2}z_i2^i\\&=z+2^w\end{split}$$即$0 \le z_1 \lt 2^{w-1}$,那么$z_2=U2T_w(z_1)=z_1=x+y+2^w$。  
    >2. 当$-2^{w-1} \le z \lt 0$，即z的$z_w$位为1，$z_{w-1}$位为1，故$$\begin{split}z_1&=zmod2^w\\&=(z_w2^w+z_{w-1}2^{w-1}+\sum_{i=0}^{w-2}z_i2^i)mod2^w\\&=\sum_{i=0}^{w-1}z_i2^i\\&=z+2^w\end{split}$$即$2^{w-1} \le z_1 \lt 2^w$,那么$z_2=U2T_w(z_1)=z_1-2^w=z+2^w-2^w=x+y$。  
    >3. 当$0 \le z \lt 2^{w-1}$，即z最高有效位为0，那么$z_1=z$，$z_2=U2T_w(z_1)=z_1=x+y$。  
    >4. 当$2^{w-1} \le z \le 2^w-2$，即z最高有效位为0，那么$z_1=z$，$z_2=U2T_w(z_1)=z_1-2^w=x+y-2^w$。  
    >综上，$$x+_w^ty=\begin{cases}x+y+2^w&-2^w \le x+y \lt-2^{w-1}&负溢出\\x+y&-2^{w-1} \le x+y \lt 2^{w-1}&正常\\x+y-2^w&2^{w-1} \le x+y \le 2^w-2&正溢出\end{cases}$$
    - 检测补码加法中的溢出
令$s\dot =x+_w^ty$，当$x \gt 0$，$y \gt 0$，$s \lt 0$时，发生正溢出；当$x \lt 0$，$y \lt 0$，$s \gt 0$时，发生负溢出。
    - 补码的非
    对于满足$TMin_w \le x \le TMax_w$的x，其补码的非$-_w^tx$由下式给出$$-_w^tx=\begin{cases}TMin_w&x=TMin_w\\-x&x \lt TMin_w\end{cases}$$
3. 无符号数的乘法  
    无符号数乘法的值，被定义为w位的值，即：对于$0 \le x,y \le UMax$$$\begin{split}x*_w^uy=(x\cdot y)mod2^w\end{split}$$
4. 补码的乘法  
    - 补码乘法的定义    
    补码乘法的值为2w位，通过截断为w位来实现乘法的值，即:对于$TMin_w \le x,y \le TMax_w$$$\begin{split}x*_w^ty=U2T_w((x\cdot y)mod2^w)\end{split}$$
    - 补码乘法与无符号数乘法的位级等价性，即：  
    $$\begin{split}U2B_w(x_u*_w^uy_u)=T2B_w(x_s*_w^ty_s)\end{split}$$
    >推导：$$\begin{split}x_u*_w^uy_u&=(x_u\cdot y_u)mod2^w\\&=[(x_s+x_{w-1}2^w)\cdot (y_s+y_{w-1}2^w)]mod2^w\\&=(x_s\cdot y_s+x_sy_{w-1}2^w+y_sx_{w-1}2^w+x_{w-1}y_{w-1}2^{2w})mod2^w\\&=(x_s\cdot y_s)mod2^w\end{split}$$  
    >则：$$\begin{split}U2T(x_u*_w^uy_u)&=U2T((x_s\cdot y_s)mod2^w)\\&=x_s*_w^ty_s\end{split}$$  
    >综上：$$\begin{split}T2B(U2T(x_u*_w^uy_u))&=U2B(x_u\ast _w^uy_u)\\&=T2B(x_s*_w^ty_s)\end{split}$$
5. 乘以常数
    - 对于任意数x，$0 \le k \lt w$,有：$$\begin{split}x2^k=x<<k\end{split}$$
    - 对于任意常数K，其位级总能表示为几组连续的‘1’和‘0’,假设一组连续的‘1’，其最高位为$k_m$、最低位为$k_n$,那么这一组连续的‘1’所表示的值K与x的乘积可用以下形式表达：$$\begin{split}&A:(x<<m)+(x<<(m-1))+……+(x<<n)\\&B:(x<<m+1)-(x<<n)\end{split}$$
6. 除以2的幂
    - 除以常数总是舍入到0。
    - 用$\lfloor x \rfloor$表示向下舍入（即向坐标轴负方向舍入）；用$\lceil x \rceil$表示向上舍入（即向坐标轴正方向舍入）。
    - 对于任意数x，$0 \le k \lt w$,有：$$\begin{split}x/2^k=x>>k\end{split}$$
    - 由于x的右移运算总是向下舍入的，对于负数向下舍入则不能保证向0舍入的规则，由此需要对x<0加上一个**偏置量**，以保证$x/2^k$是向上舍入的，表达式：$$\begin{split}(x+1<<k-1)>>k等价于\lceil x/2^k\rceil\end{split}$$
    > 推导：假设$x=py+r$,$y \gt 0$,$0 \le r \lt y$,则$$\begin{split}\lfloor (x+y-1)/y \rfloor &= \lfloor (py+y-1+r)/y \rfloor\\&=p+\lfloor (y-1+r)/y \rfloor\end{split}$$
    > 当$r = 0$时，$$\begin{split}\lfloor (y-1)/y \rfloor&=\lfloor 1-1/y \rfloor\\&=0\end{split}$$
    > 当$1\le r \lt y$时，$y \le r+y-1 \lt 2y-1$,$$\begin{split}\lfloor (y-1+r)/y \rfloor =1\end{split}$$
    > 综上，y除x，将得到q或q+1,即当$y=2^k$时，$$\begin{split}(x+1<<k-1)>>k等价于\lceil x/2^k\rceil\end{split}$$
## 浮点数
### 二进制小数
对于形如$b_mb_{m-1}b_{m-2}……b_1b_0.b_{-1}b_{-2}……b_{-n}$二进制数,其对应的小数b用下式表示：$$\begin{split}b=\sum_{i=-n}^mb_i2^i\end{split}$$
### IEEE浮点表示
1. IEEE浮点数表示，是使用三段字段对浮点数进行编码，以下表表示： 
 
    |字段 |位数 |编码表示|
    |-|-|-|
    |符号位s|1 |1表示负数，0表示正数|
    |阶码exp|k=8(float)/k=11（double)|阶码E=e-Bias(规格化）；E=1-Bias(非规格化）|
    |小数frac|n=23(float)/n=52(double)|尾数M=1+f(规格化)；M=f(非规格化)|
    
    其中，规格化表示$e \neq 0 $,$e \neq UMax$；非规格化表示$e=0$；而$e=UMax$,$f=0$表示$\infty$；$e=UMax$，$f\neq 0$表示NaN。  
    偏置:$Bias=2^{k-1}-1$  
    浮点数$V=2^E\cdot M$  
    
2. 浮点数的舍入  
IEEE浮点数向偶数舍入，这表示当b为a、c的平均数时，b向偶数舍入，当b小于平均数时向下舍入，大于平均数时向上舍入。
3. float、double和int类型的转化
浮点数与整数的转换是基于值的，而不是基于位级的不同表示；  
float转化为int：阶码小于23,则能精确转化为整数；若阶码大于23,则转化的值向零舍入；若阶码大于31,则转化为INT_MIN。double同理。
int转化为float：整型数值的绝对值小于等于22位，则能精确转换；若大于22位则舍入；double同理。
double转换为float：由于范围广、精度高，会造成溢出及舍入。
int或float转换为doubule：能保持精确的数值。
