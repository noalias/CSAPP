### 静态链接
静态链接程序LD以一组可**重定位**的目标文件作为输入，生成完全链接的、可以加载到内存和可执行的文件。

主要完成两个任务：
1. **符号解析**,将符号引用与符号定义关联起来
2. **重定位**,汇编器生成地址从0开始的代码和数据节，链接器将符号定义与内存位置关联起来，并使符号引用指向这些内存位置
#### 目标文件
1. 可重定位的目标文件
2. 可加载、可执行文件
3. 共享目标文件
#### 目标文件的格式
Linux下目标文件采用ELF(可执行可链接)格式,包含:ELF头、节和节头部表
**节头部表**，记录节相关的信息

**节**，主要包含机器代码、只读数据（如字符串、switch语句的跳转表）符号定义、符号表（存放符号定义的信息）等

- .symtab符号表，记录符号的定义信息，如符号名、类型（函数或数据）、本地或全局、所处的节、离节起始位置的偏移以及大小等；
- .text节，机器代码；
- .data节，已初始的全局和静态变量；
- .bss节，未初始的全局和静态变量，以及初始为〇的全局、静态变量；
- 伪节，在节头部表中没有条目；ABS记录不该重定位的符号，UNDEF记录未定义的符号，COMMON记录未被分配位值的未初始化的数据（一般将未初始化的全局变量记录在COMMON中，其余未初始化数据记录在.bass节中）。
#### 符号解析
**符号**，可重定位目标模块m有三种符号：
1. m定义的全局符号，包括非static的函数和全局变量
2. 其他模块定义的被m引用的全局符号，即外部符号
3. m定义和引用的局部符号，包括static的函数和全局变量

定义在函数中的局部变量是在栈上分配空间的，相反定义为static的过程局部变量是编译器在可重定位模块节中定义的，并在符号表中有唯一的名字

**符号解析**，将符号引用与输入的可重定位的目标文件的符号表中的符号定义关联起来

对于局部符号引用和符号定义处于相同的模块中的情况，编译器确保模块中每个局部符号有一个定义，并且其名字是唯一的

对于全局符号引用和符号定义不在同一模块中的情况，编译器会生成一个_链接器符号表条目_，并假设符号定义存在其他模块中，如果链接器在其他模块中未找到符号定义则发出错误并终止

对于定义在多个模块中的符号，编译器将符号识别为**强**（函数和已初始化的全局变量）和**弱**（未初始化的全局变量），链接器根据以下规则处理同名符号：
1. 不允许出现多个同名强符号
2. 强符号与弱符号同名，选择强符号
3. 多个弱符号同名，任意选取

**静态库**，是指被封装起来的一组独立的目标模块（由相关的函数编译而来），链接时，链接器将只复制被程序引用的目标模块

**使用静态库解析引用**，链接器从左至右按照命令行上目标文件和归档文件出现的顺序，依次解析；链接器维护一个可重定位目标模块集合E（这个集合的文件最终合并为可执行文件）、未解析符号集合U（引用但未定义的符号）、解析文件后的定义符号集合D，链接器参照以下规则来解析引用：
1. 初始时，集合E、U、D为空；
2. 链接器会依次解析命令行上输入文件file，如果file为目标文件，将file记录在E中，并根据file中的内容更新U和D，并继续下一个文件；
3. 如果file为存档文件，则根据U中记录的未定义符号，匹配file中的归档文件，如果file中的一个成员m定义了U中的某个符号，将m记录到E中，并根据m的内容更新U和D，遍历file成员，直到U和D不在变化，并继续下一个文件；
4. 以上步骤完成后，若U非空，则链接器输出错误，否则合并并重定位E中文件。
#### 重定位
合并输入模块，为每个符号分配运行时地址，步骤：
- **重定位节和符号定义**，链接器首先将各个输入模块中相同类型的节聚合为一个节，比如所有输入模块中.data节将合并为一个.data节，然后链接器将运行时的内存地址赋给聚合节、输入模块定义的节和输入模块定义的每个符号;
- **重定位节中的符号引用**，链接器修改代码节和数据节中每个符号引用，使其指向正确的内存地址，这一步依赖可重定位目标模块中__重定位条目__的数据结构。

**重定位条目**，编译器遇到符号引用时，生成一个重定位条目，以此告诉链接器合并成可执行文件时如何修改引用，代码重定位条目放在.rel.text节中，已初始化的数据重定位条目放在.rel.data节中。

重定位条目可用以下结构表示：
```////c
typedef struct {
    long offset;
    long type:32,
         symbol:32;
    long addend;
} Elf64_Rela;
```
字段`offset`表示引用相对于所在节的地址偏移，字段`type`表示重定位类型（重定位引用的方法，如`R_X86_64_PC32`使用PC相对地址引用，`R_X86_64_32`使用绝对地址的引用），字段`symbol`表示引用的名字，字段`addend`表示对`offset`的修正值。

对于节s中的引用r重定位方法如下：
```
foreach section s { /* 遍历节 */
    foreach relocation entry r { /* 遍历节中的引用 */
        refptr = s + r.offset;   /* 重定位条目相对节的地址 */

        if (r.type == R_X86_64_PC32) {
            refaddr = ADDR(s) + r.offset; /* 运行使地址 */
            *refptr = (unsigned) (ADDR(r.symbol) + r.addend -
            refaddr); /* 重定位条目的值，PC相对的 */
        }

        if (r.type = R_X86_64_32)
            *refptr = (unsigned) (ADDR(r.symbol) + r.addend);
    }
}
```
#### 可执行目标文件
链接器将目标文件合并为一个可执行文件，ELF可执行文件具有以下信息：
1. **ELF头**:描述文件的总体格式，并包括程序的入口点
2. **段头部表**:描述可执行文件连续的片与内存片段的映射关系
3. **.init**:定义_init函数，程序初始化代码会调用该函数

其余与目标模块类似，同时可执行文件不再保留rel节
#### 加载可执行目标文件



