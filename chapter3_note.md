# 程序的机器级表示
## c程序汇编及反汇编
### gcc
主要包括以下过程：
1. **预处理**：调用预处理器包含#include命令指定的文件，扩展#define命令指定的宏
2. **编译**：调用编译器将c源文件转化为汇编代码，\*.c-->\*.s
3. **汇编**: 调用汇编器将汇编代码转化为二进制目标文件，\*.s-->\*.o
4. **链接**: 调用链接器将目标代码与库函数代码合并，并产生可执行文件，\*.o-->\*
5. 优化等级：执行gcc命令时，优化等级越高，汇编代码与c源文件的结构形式偏离越大，使用-Og选项可以将c文件编译成c结构形式的汇编代码
### ISA（指令集体系结构）
定义了处理器状态、指令格式及指令对状态的影响，其中处理器状态包含：
1. 程序计数器pc：给出下一条指令的地址
2. 寄存器文件：存储64位的整型值，共16个
3. 条件寄存器：记录最近执行的指令状态信息
4. 向量寄存器：保存一个或多个整数或浮点数
### 反汇编器
可以将执行文件转化为类似汇编代码的格式
## 数据
### ATT汇编代码格式
1. 指令加入后缀表示操作数的长度
2. 寄存器用%前缀标识
3. 内存取值用括号`（）`包括寄存器表示，这将计算寄存器的值作为内存地址
### 数据大小
1. 用**字节**(byte)表示8位数据，用**字**(word)表示16位数据，用**双字**（double words)表示32位数据，用**四字**(quad words)表示64位数据
2. 汇编代码中，指令后接后缀以指明操作的数据长度，c中数据类型与汇编代码数据对应关系如下：

   C数据类型|汇编数据格式|汇编代码后缀|数据长度(字节)
   :---|:---|:---:|:---:
   char|字节|b|1
   short|字|w|2
   int|双字|l|4
   long|四字|q|8
   char \*|四字|q|8
   float|单精度|s|4
   double|双精度|l|8

### 操作数(operand)
1. 立即数(immediate)：常数,取值$Imm=Imm
2. 寄存器(register): 表示寄存器的内容，16个寄存器中的低位1字节、2字节、4字节和8字节都可以作为一个操作数，取值R[ra]
3. 内存: 表示内存里的值，根据计算出来的地址访问内存并引用内存的值，取值M[Addr],Addr语法为：Imm（rb,ri,s)=Imm+R[rb]+R[ri]xs,s为伸缩因子：1,2,4或8
## 指令
### 数据传送
1. MOV类 --> `mov S,D` 将源S中的数据传送至目的D中
   - 源操作数S可以是立即数、寄存器和内存地址
   - 目的操作数D可以是寄存器和内存地址
   - 源与目的操作数不能同时为内存地址，要做相关的操作，需要将数据先传送至寄存器，再传送至内存
   - 操作数为寄存器时需要与指令后缀指示的数据大小相匹配
   - 对于指令`movl`其目的操作数D为寄存器时，自动将寄存器高4字节置为0
   - 对于指令`movq`其源操作数S只能是经过符号扩展的32位补码
   - 对于指令`movabsq`其源操作数为64位立即数，而目的操作数为寄存器
2. MOVZ与MOVS类
   - MOVZ与MOVS指令都是对源操作数S做扩展以匹配目的操作数D，并进行传送；前者做零扩展，后者做符号扩展
   - 源操作数S不能是立即数，目的操作数D为寄存器
   - MOVZ类指令中没有`movzql`指令，该功能由`movl`实现
   - MOVS类指令中的`cltq`是将`%eax`符号扩展为`%rax`
3. 压入和弹出数据 --> `push S & pop D`
   > push & pop指令是对程序栈进行数据操作的，程序栈是由栈指针`%rsp`保存地址的连续内存区域，当前`%rsp`指向的内存为栈顶  
   - `pushq S` --> `subq $8,%rsp`; `movq S,(%rsp)`
   - `popq D` --> `movq (%rsp),D`; `addq $8,%rsp`
### 算术和逻辑
1. 加载有效地址--> `leaq S,D`
   - S为内存地址，D为寄存器
   - 指令并不从内存中取值，而是操作内存地址（Adrr）本身
   - Adrr有一套计算公式，这样`leaq`指令具有做简单计算的功能
2. 一元和二元操作
   - 一元指令：`INC D`:D自加；`DEC D`:D自减；`NEG D`:D取负；`NOT D`:D取补
   - 二元指令：`ADD S,D`；`SUB S,D`; `IMUL S,D`; `XOR S,D`; `OR S,D`; `AND S,D`
3. 移位操作
   - 左移：SAL k, D/ SHL k, D; 算术右移：SAR k, D; 逻辑右移：SHR k，D
   >移位量k可以是立即数，也可以是存放在寄存器`%cl`中的数（即，移位的编码范围达255）；假设，操作数的位数为w，而2^m=w,则`%cl`中低m位B2U(m)=k
4. 特殊的算术操作
128位乘法及64位除法
   - 指令:`imulq S`:有符号乘法; `mulq S`:无符号乘法; `idivq S`:有符号除法; `divq S`:无符号除法; `clto`:扩展%rax的符号位
   - 对于乘法操作数S作为一个显式的乘数,另一个乘数固定为寄存器%rax中的值;积为128位,其高64位的值存入%rdx中,低64位存入%rax中
   - 对于除法操作数S为除数,被除数固定为128位的寄存器:高64位为%rdx,低64位为%rax,其商存入%rax中,余数存入%rdx中
   - 另外,对于有符号被除数其高64位由`clto`指令将%rax中的符号扩展至%rdx中
## 控制
### 条件码
与整数寄存器(通用目的寄存器）一样,条件码寄存器(单个位)也是用来描述CPU状态
1. 最常用的条件码有:

   条件码|标志|功能
   ---|---|---
   CF|进位|检查无符号数的溢出
   ZF|零|检查最近的结果为0
   SF|符号|检查最近的结果为负
   OF|溢出|检查补码溢出(正或负)

2. 影响条件码的指令
   除leaq算术指令外，所有的算术和逻辑指令都能在生成目的操作数的同时改变条件码寄存器；  
   有两类指令只改变条件码寄存器，而不对其他寄存器产生影响：
   - `CMP`指令: `cmp S1,S2` --> 比较`S2-S1`
   - `TEST`指令：`test S1,S2` --> 测试 `S2&S1`
3. 访问条件码
   条件码无法直接读取，通常根据条件码的组合，来执行相关的指令，主要分为三类：
   - `SET`指令，根据条件码的组合将一个单字节寄存器或内存设置为1或0
   - 条件跳转指令，根据条件码的组合使程序从跳转的目标地址往下执行
   - 条件传送指令，根据条件码的组合进行数据传送  
   以上相关指令的后缀，对应于条件码的某种组合方式

   指令后缀|条件码组合方式|描述
   :---|---|:---
   e|ZF|相等/零
   ne|~ZF|不等/非零
   s|SF|负数
   ns|~SF|非负数
   g|~(SF^OF)&~ZF|大于(有符号)
   ge|~(SF^OF)|大于等于(有符号)
   l|SF^OF|小于(有符号)
   le|(SF^OF)\|ZF|小于等于(有符号)
   a|~CF&~ZF|超过(无符号)
   ae|~CF|超过或相等(无符号)
   b|CF|低于(无符号)
   be|CF\|ZF|低于或等于(无符号)
### 条件跳转
跳转分为直接跳转和间接跳转，汇编代码中，直接跳转是在跳转指令后接一个标号，直接指明跳转的目的，而间接跳转的目标是对寄存器或内存的引用，即在寄存器或内存操作数前加*****。  
条件跳转使可根据条件后缀执行的直接跳转指令
1. 跳转目标的编码
   采用**PC相对的**编码方式，即，跳转目标地址与跳转指令的下一条指令地址之差，这种编码方式主要体现在**目标文件**中。
