# 程序的机器级表示
## c程序汇编及反汇编
### gcc
主要包括以下过程：
1. **预处理**：调用预处理器包含#include命令指定的文件，扩展#define命令指定的宏
2. **编译**：调用编译器将c源文件转化为汇编代码，\*.c-->\*.s
3. **汇编**: 调用汇编器将汇编代码转化为二进制目标文件，\*.s-->\*.o
4. **链接**: 调用链接器将目标代码与库函数代码合并，并产生可执行文件，\*.o-->\*
5. 优化等级：执行gcc命令时，优化等级越高，汇编代码与c源文件的结构形式偏离越大，使用-Og选项可以将c文件编译成c结构形式的汇编代码
### ISA（指令集体系结构）
定义了处理器状态、指令格式及指令对状态的影响，其中处理器状态包含：
1. 程序计数器pc：给出下一条指令的地址
2. 寄存器文件：存储64位的整型值，共16个
3. 条件寄存器：记录最近执行的指令状态信息
4. 向量寄存器：保存一个或多个整数或浮点数
### 反汇编器
可以将执行文件转化为类似汇编代码的格式
## 数据
### ATT汇编代码格式
1. 指令加入后缀表示操作数的长度
2. 寄存器用%前缀标识
3. 内存取值用括号`（）`包括寄存器表示，这将计算寄存器的值作为内存地址
### 数据大小
1. 用**字节**(byte)表示8位数据，用**字**(word)表示16位数据，用**双字**（double words)表示32位数据，用**四字**(quad words)表示64位数据
2. 汇编代码中，指令后接后缀以指明操作的数据长度，c中数据类型与汇编代码数据对应关系如下：

   C数据类型|汇编数据格式|汇编代码后缀|数据长度(字节)
   :---|:---|:---:|:---:
   char|字节|b|1
   short|字|w|2
   int|双字|l|4
   long|四字|q|8
   char \*|四字|q|8
   float|单精度|s|4
   double|双精度|l|8

### 操作数(operand)
1. 立即数(immediate)：常数,取值$Imm=Imm
2. 寄存器(register): 表示寄存器的内容，16个寄存器中的低位1字节、2字节、4字节和8字节都可以作为一个操作数，取值R[ra]
3. 内存: 表示内存里的值，根据计算出来的地址访问内存并引用内存的值，取值M[Addr],Addr语法为：Imm（rb,ri,s)=Imm+R[rb]+R[ri]xs,s为伸缩因子：1,2,4或8
## 指令
### 数据传送
1. MOV类 --> `mov S,D` 将源S中的数据传送至目的D中
   - 源操作数S可以是立即数、寄存器和内存地址
   - 目的操作数D可以是寄存器和内存地址
   - 源与目的操作数不能同时为内存地址，要做相关的操作，需要将数据先传送至寄存器，再传送至内存
   - 操作数为寄存器时需要与指令后缀指示的数据大小相匹配
   - 对于指令`movl`其目的操作数D为寄存器时，自动将寄存器高4字节置为0
   - 对于指令`movq`其源操作数S只能是经过符号扩展的32位补码
   - 对于指令`movabsq`其源操作数为64位立即数，而目的操作数为寄存器
2. MOVZ与MOVS类
   - MOVZ与MOVS指令都是对源操作数S做扩展以匹配目的操作数D，并进行传送；前者做零扩展，后者做符号扩展
   - 源操作数S不能是立即数，目的操作数D为寄存器
   - MOVZ类指令中没有`movzql`指令，该功能由`movl`实现
   - MOVS类指令中的`cltq`是将`%eax`符号扩展为`%rax`
3. 压入和弹出数据 --> `push S & pop D`
   > push & pop指令是对程序栈进行数据操作的，程序栈是由栈指针`%rsp`保存地址的连续内存区域，当前`%rsp`指向的内存为栈顶  
   - `pushq S` --> `subq $8, %rsp; movq S,(%rsp)`
   - `popq D` --> `movq (%rsp),D; addq $8, %rsp`
### 算术和逻辑
1. 加载有效地址--> `leaq S,D`
   - S为内存地址，D为寄存器
   - 指令并不从内存中取值，而是操作内存地址（Adrr）本身
   - Adrr有一套计算公式，这样`leaq`指令具有做简单计算的功能
2. 一元和二元操作
   - 一元指令：INC D: D自加；DEC D：D自减；NEG D: D取负；NOT D：D取补
   - 二元指令：ADD S，D；SUB S, D; IMUL S, D; XOR S, D; OR S, D; AND S, D
3. 移位操作
   - 左移：SAL k, D/ SHL k, D; 算术右移：SAR k, D; 逻辑右移：SHR k，D
   >移位量k可以是立即数，也可以是存放在寄存器`%cl`中的数（即，移位的编码范围达255）；假设，操作数的位数为w，而2^m=w,则`%cl`中低m位B2U(m)=k




