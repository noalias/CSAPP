# 程序的机器级表示
## c程序汇编及反汇编
1. 使用gcc命令，按照以下过程产生最终的可执行程序
   - **预处理**：调用预处理器包含#include命令指定的文件，扩展#define命令指定的宏
   - **编译**：调用编译器将c源文件转化为汇编代码，\*.c-->\*.s
   - **汇编**: 调用汇编器将汇编代码转化为二进制目标文件，\*.s-->\*.o
   - **链接**: 调用链接器将目标代码与库函数代码合并，并产生可执行文件，\*.o-->\*
   - 优化等级：执行gcc命令时，优化等级越高，汇编代码与c源文件的结构形式偏离越大，使用-Og选项可以将c文件编译成c结构形式的汇编代码
2. ISA（指令集体系结构）定义了处理器状态、指令格式及指令对状态的影响，其中处理器状态包含：
   - 程序计数器pc：给出下一条指令的地址
   - 寄存器文件：存储64位的整型值，共16个
   - 条件寄存器：记录最近执行的指令状态信息
   - 向量寄存器：保存一个或多个整数或浮点数
3. 反汇编器，可以将执行文件转化为类似汇编代码的格式
## 数据
1. ATT汇编代码格式
   - 指令加入后缀表示操作数的长度
   - 寄存器用%前缀标识
   - 内存取值用括号`（）`包括寄存器表示，这将计算寄存器的值作为内存地址
2. 数据大小
   - 用**字节**(byte)表示8位数据，用**字**(word)表示16位数据，用**双字**（double words)表示32位数据，用**四字**(quad words)表示64位数据
   - 汇编代码中，指令后接后缀以指明操作的数据长度，c中数据类型与汇编代码数据对应关系如下：

     C数据类型|汇编数据格式|汇编代码后缀|数据长度(字节)
     :---|:---|:---:|:---:
     char|字节|b|1
     short|字|w|2
     int|双字|l|4
     long|四字|q|8
     char \*|四字|q|8
     float|单精度|s|4
     double|双精度|l|8

3. 操作数(operand)
   - 立即数(immediate)：常数,取值$Imm=Imm
   - 寄存器(register): 表示寄存器的内容，16个寄存器中的低位1字节、2字节、4字节和8字节都可以作为一个操作数，取值R[ra]
   - 内存: 表示内存里的值，根据计算出来的地址访问内存并引用内存的值，取值M[Addr],Addr语法为：Imm（rb,ri,s)=Imm+R[rb]+R[ri]xs,s为伸缩因子：1,2,4或8
## 指令
1. 数据传送
   - MOV类-->`mov S,D` 将源S中的数据传送至目的D中
     - 源操作数S可以是立即数、寄存器和内存地址
     - 目的操作数D可以是寄存器和内存地址
     - 源与目的操作数不能同时为内存地址，要做相关的操作，需要将数据先传送至寄存器，再传送至内存
     - 操作数为寄存器时需要与指令后缀指示的数据大小相匹配
     - 对于指令`movl`其目的操作数D为寄存器时，自动将寄存器高4字节置为0
     - 对于指令`movq`其源操作数S只能是经过符号扩展的32位补码
     - 对于指令`movabsq`其源操作数为64位立即数，而目的操作数为寄存器
   - MOVZ与MOVS类
     > MOVZ与MOVS指令都是对源操作数S做扩展以匹配目的操作数D，并进行传送；前者做零扩展，后者做符号扩展  
     > 源操作数S不能是立即数，目的操作数D为寄存器  
     > MOVZ类指令中没有`movzql`指令，该功能由`movl`实现  
     > MOVS类指令中的`cltq`是将`%eax`符号扩展为`%rax`  
   - 压入和弹出数据 --> push S & pop D
     > push & pop指令是对程序栈进行数据操作的，程序栈是由栈指针`%rsp`保存地址的连续内存区域，`%rsp`指向的内存为栈顶，而push & pop指令总是对栈顶进行操作
